import { NextApiRequest, NextApiResponse } from 'next';
import { getToken } from 'next-auth/jwt';
import { cachedPrisma } from '../../../lib/cached-prisma';
import { rateLimiter } from '../../../lib/rate-limiter';
import { revalidateAfterChange } from '../../../lib/cache-revalidator';
import { unstable_cache } from 'next/cache';
import { bigint_filter } from '../enrollments';

// Cached applicant statistics calculation
const getCachedApplicantStats = unstable_cache(
  async (cohortId?: string, mobilizerCode?: string) => {
    const baseWhere = {
      role: 'APPLICANT' as const,
      userCohort: cohortId ? {
        some: {
          cohortId: cohortId,
        },
      } : undefined,
      ...(mobilizerCode ? {
        profile: {
          referrer: {
            fullName: mobilizerCode,
          },
        },
      } : {}),
    };

    const count = await cachedPrisma.user.count({
      where: baseWhere,
    });

    // Get cohort-specific course IDs for filtering enrollments
    const cohortCourseIds = cohortId ? await cachedPrisma.cohortCourse.findMany({
      where: { cohortId },
      select: { course_id: true },
    }).then(results => results.map(r => r.course_id)) : [];

    return {
      count,
      cohortCourseIds,
    };
  },
  ['applicant-stats'],
  {
    tags: ['applicants', 'dashboard'],
    revalidate: 300, // 5 minutes
  }
);

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  // Rate limiting
  const identifier = req.headers['x-forwarded-for'] || req.connection.remoteAddress || 'anonymous';
  const allowed = await rateLimiter.limitApiRequest('applicants', identifier as string, 100, 60000);
  
  if (!allowed) {
    return res.status(429).json({
      error: 'Rate limit exceeded',
      message: 'Too many requests, please try again later',
    });
  }

  const token = await getToken({ req });
  if (!token) {
    return res.status(401).send({
      error: 'You must be signed in to view the protected content on this page.',
    });
  }

  // Approve Applicant
  if (req.method === 'PATCH') {
    if (
      token?.userData?.role !== 'SUPERADMIN' &&
      token?.userData?.role !== 'ADMIN'
    ) {
      return res.status(403).send({
        error: 'Unauthorized.',
      });
    }

    const body = typeof req.body === 'object' ? req.body : JSON.parse(req.body);
    
    try {
      const _users = await cachedPrisma.user.findMany({
        where: {
          id: {
            in: body.ids,
          },
          role: 'APPLICANT',
        },
        include: {
          userCohort: {
            include: {
              cohort: true,
              enrollments: true,
            },
          },
        },
      });

      if (!_users.length) {
        return res.status(404).send({ error: 'user not found' });
      }

      // Process user approvals (simplified for caching)
      for (let user of _users) {
        const active_enrollment = user?.userCohort?.pop()?.enrollments?.pop();
        const course_id = `${active_enrollment?.course_id}`;
        const enrollmentUID = `${active_enrollment?.uid}`;

        if (user.thinkific_user_id === null) {
          // Create Thinkific user and enrollment
          // This would integrate with the existing Thinkific API logic
          // For now, we'll just update the local database
          await cachedPrisma.user.update({
            where: {
              id: user.id,
            },
            data: {
              thinkific_user_id: `temp_${user.id}`, // Placeholder
            },
          });

          await cachedPrisma.enrollment.update({
            where: {
              uid: enrollmentUID,
            },
            data: {
              enrolled: true,
            },
          });
        } else {
          // Update existing enrollment
          await cachedPrisma.enrollment.update({
            where: {
              uid: enrollmentUID,
            },
            data: {
              enrolled: true,
            },
          });
        }
      }

      // Revalidate caches after approving applicants
      await revalidateAfterChange('applicant');

      return res.status(201).send({ message: 'success' });
    } catch (error: any) {
      console.error(error.response?.data || error);
      return res
        .status(400)
        .send({ message: error.response?.data || error.message });
    }
  }

  // Delete Applicants
  if (req.method === 'DELETE') {
    if (token?.userData?.role !== 'SUPERADMIN') {
      return res.status(403).send({
        error: 'Unauthorized.',
      });
    }

    const body = typeof req.body === 'object' ? req.body : JSON.parse(req.body);
    
    try {
      const result = await cachedPrisma.user.deleteMany({
        where: {
          id: { in: body.ids },
          role: 'APPLICANT',
        },
      });

      // Revalidate caches after deleting applicants
      await revalidateAfterChange('applicant');

      return res.status(200).send({ message: 'Users Deleted' });
    } catch (err: any) {
      console.error(err);
      if (err instanceof Error) {
        return res.status(400).send(err.message);
      }
      return res.status(400).send('An error occurred');
    }
  }

  // Get Applicants
  const {
    page,
    limit,
    filter,
    query,
    cohortId,
    includeAssessment,
    mobilizerId,
    mobilizerCode,
  }: {
    page?: string;
    limit?: string;
    filter?: string;
    query?: string;
    cohortId?: string;
    includeAssessment?: string;
    mobilizerId?: string;
    mobilizerCode?: string;
  } = req.query;

  const take = parseInt(typeof limit == 'string' && limit ? limit : '30');
  const skip = take * parseInt(typeof page == 'string' ? page : '0');

  try {
    // Get cached applicant data
    const applicantData = await cachedPrisma.getCachedApplicants({
      page: parseInt(page as string) || 0,
      limit: take,
      filter,
      query,
      cohortId,
      mobilizerId,
      mobilizerCode,
    });

    // Get cached statistics
    const stats = await getCachedApplicantStats(cohortId, mobilizerCode);

    return res.status(200).json(
      bigint_filter({
        ...applicantData,
        ...stats,
      })
    );
  } catch (err: any) {
    console.error(err.message);
    return res.status(400).send(err.message);
  }
}
